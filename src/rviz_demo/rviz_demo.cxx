/*
* (c) Copyright, Real-Time Innovations, 2012.  All rights reserved.
* RTI grants Licensee a license to use, modify, compile, and create derivative
* works of the software solely for use with RTI Connext DDS. Licensee may
* redistribute copies of the software provided that all such copies are subject
* to this license. The software is provided "as is", with no warranty of any
* type, including any warranty for fitness for any purpose. RTI is under no
* obligation to maintain or support the software. RTI shall not be liable for
* any incidental or consequential damages arising out of the use or inability
* to use the software.
*/

/** ================================================================
 * pointmap_demo.cxx
 * From code automatically generated by the rtiddsgen command:
 *   rtiddsgen -language C++11 -example <arch> cros2_types.idl
 *
 * Publishes ROS2 PointCloud2, OccupancyGrid, and other data, 
 *  for viewing in ROS2 RViz2.
 **/

#include <algorithm>
#include <iostream>
#include <cmath>
#include <dds/pub/ddspub.hpp>
#include <dds/sub/ddssub.hpp>
#include <dds/core/ddscore.hpp>
#include <rti/util/util.hpp>                // for sleep()
#include "rviz_demo_typesPlugin.hpp"

#define PI_F                    ((float)3.14159265359)
#define POSE_MARKERS_MAX    10

// struct for holding position/orientation/label of pose and marker
typedef struct vector3d {
    float x;
    float y;
    float z;
} Vec3d_t;
typedef struct vector4d {
    float x;
    float y;
    float z;
    float w;
} Vec4d_t;

typedef struct pose_marker_info {
    Vec3d_t position;
    Vec4d_t orientation;
    std::string label;
} PoseMarkerInfo;

 /** ----------------------------------------------------------------
  * tstamp_get()
  * utility timestamp getter
  **/
void tstamp_get(timespec *tStamp)
{
#ifdef WIN32
    timespec_get(tStamp, TIME_UTC);
#else
    clock_gettime(CLOCK_REALTIME, tStamp);
#endif
    return;
}

// returns random float values within a specified range
float randFloatInRange(float low, float high)
{
    float rval = ((float) rand() / (float)RAND_MAX);
    float rspan = high-low;
    return low + (rval * rspan);
}
// returns random double values within a specified range
double randDoubleInRange(double low, double high)
{
    double rval = ((double) rand() / (double)RAND_MAX);
    double rspan = high-low;
    return low + (rval * rspan);
}


/** -----------------------------------------------------------------
 * image_scale_image
 * Scale input image to ROS2 'Image' export size
 */
void image_scale_image(uint8_t *imgBuf, uint32_t inX, uint32_t inY, uint8_t *outBuf, uint32_t outX, uint32_t outY)
{
    float factor_X = (((float)inX) / outX);
    float factor_Y = (((float)inY) / outY);
    uint32_t ipX = 0;
    uint32_t ipY = 0;
    uint32_t addPad = ((inX * 3) % 4);
    if (addPad) addPad = 4 - addPad;

    for (uint32_t idxY = 0; idxY < outY; idxY++) {
        for (uint32_t idxX = 0; idxX < outX; idxX++) {
            // for each idxX, get the average of the pixels in the (factor_x * factor_y) area nearby
            uint32_t pixR = 0;
            uint32_t pixG = 0;
            uint32_t pixB = 0;
            uint32_t pixCnt = 0;
            ipX = (uint32_t)(idxX * factor_X);
            uint32_t iStopX = (uint32_t)((idxX + 1) * factor_X);
            ipY = (uint32_t)(idxY * factor_Y);
            uint32_t iStopY = (uint32_t)((idxY + 1) * factor_Y);
            for (; ipY < iStopY; ipY++) {
                for (uint32_t itX = ipX; itX < iStopX; itX++) {
                    pixR += imgBuf[(ipY * inX * 3) + (itX * 3) + (addPad * ipY)];
                    pixG += imgBuf[(ipY * inX * 3) + (itX * 3) + (addPad * ipY) + 1];
                    pixB += imgBuf[(ipY * inX * 3) + (itX * 3) + (addPad * ipY) + 2];
                    pixCnt++;
                }
            }
            // assign the averages to the output array
            outBuf[((outY - idxY - 1) * outX * 3) + (idxX * 3) + 0] = (pixR / pixCnt);
            outBuf[((outY - idxY - 1) * outX * 3) + (idxX * 3) + 1] = (pixG / pixCnt);
            outBuf[((outY - idxY - 1) * outX * 3) + (idxX * 3) + 2] = (pixB / pixCnt);
        }
    }
    return;
}


/** -----------------------------------------------------------------
 * ogrid_scale_image
 * convert and scale an image to the 
 */
void ogrid_scale_image(uint8_t *imgBuf, uint32_t inX, uint32_t inY, int8_t *outBuf, uint32_t outX, uint32_t outY)
{
    float factor_X = (((float)inX) / outX);
    float factor_Y = (((float)inY) / outY);
    uint32_t ipX = 0;
    uint32_t ipY = 0;
    uint32_t addPad = ((inX * 3) % 4);
    if (addPad) addPad = 4 - addPad;
    for (uint32_t idxY = 0; idxY < outY; idxY++) {
        for (uint32_t idxX = 0; idxX < outX; idxX++) {
            // for each idxX, get the average of the pixels in the factor_x x factor_y area nearby
            uint32_t pixSum = 0;
            uint32_t pixCnt = 0;
            ipX = (uint32_t)(idxX * factor_X);
            uint32_t iStopX = (uint32_t)((idxX + 1) * factor_X);
            ipY = (uint32_t)(idxY * factor_Y);
            uint32_t iStopY = (uint32_t)((idxY + 1) * factor_Y);
            for (; ipY < iStopY; ipY++) {
                for (uint32_t itX = ipX; itX < iStopX; itX++) {
                    pixSum += imgBuf[(ipY * inX * 3) + (itX * 3) + (addPad * ipY)];
                    pixSum += imgBuf[(ipY * inX * 3) + (itX * 3) + (addPad * ipY) + 1];
                    pixSum += imgBuf[(ipY * inX * 3) + (itX * 3) + (addPad * ipY) + 2];
                    pixCnt++;
                }
            }
            // average, invert and scale to 99--0 range (black--white)
            outBuf[(idxY * outX) + idxX] = (uint8_t)((765.0F - (((float)pixSum) / pixCnt)) / 7.7273F);
        }
    }
    return;
}


 /** ----------------------------------------------------------------
  * read_ptcloud_bitmap()
  * Given a filename for a larger .bmp file, open and read the
  *  contents into a new allocated array pointed-to by *imgData.
  * Returns 0 if no error.
  **/
int read_ptcloud_bitmap(uint8_t **imgData, uint32_t *imgRows, uint32_t *imgCols, const char *fileName)
{
    FILE *fp;
    if ((fp = fopen(fileName, "rb")) == NULL) {
        fprintf(stderr, "ERROR: cannot open file %s for reading (%s:%d)\n", fileName, __FILE__, __LINE__);
        return -1;
    }

    // read in the first part of the file to get stats
    uint8_t bmpHeader[35];
    int bIdx = 0;
    bIdx = (int)fread((uint8_t *)bmpHeader, sizeof(uint8_t), 34, fp);

    // bytes 2-5 are the total size of the file
    uint32_t fileSize = *((uint32_t *)&bmpHeader[2]);

    // bytes 18-21 are image width (X dim, number of columns)
    *imgCols = *((uint32_t *)&bmpHeader[18]);

    // bytes 22-25 are image height (Y dim, number of rows)
    *imgRows = *((uint32_t *)&bmpHeader[22]);

    // bytes 14-10 are the offset to the start of the data
    uint32_t dOffset = *((uint32_t *)&bmpHeader[10]);

    // Allocate memory for size of image
    uint32_t imgDataSize = fileSize - dOffset;
    if ((*imgData = (uint8_t *)malloc(imgDataSize)) == NULL) {
        fprintf(stderr, "ERROR: alloc fail of (%u) at (%s:%d)\n", imgDataSize, __FILE__, __LINE__);
        return -2;
    }

    // read the data
    fseek(fp, dOffset, SEEK_SET);
    fread((uint8_t *)*imgData, sizeof(uint8_t), (imgDataSize), fp);
    fclose(fp);
    return 0;
}

/** ----------------------------------------------------------------
 * ptcloud_build_img_export()
 * Given an image buffer containing 24bpp .bmp data, make pseudorandom 
 *  pixel selections for pointcloud2 export.
 * In->out transform will be:
 *  X(0:ImgCols) --> X(-5:5)
 *  Y(0:ImgRows) --> Z(0:10)
 *  Pixel Color  --> Y(-5:5)
 **/
void ptcloud_build_img_export(uint8_t *imgData, int imgRows, int imgCols, uint32_t pointsTotal, float *ptcData)
{
    static uint32_t lfsr = (uint32_t)rand();
    uint32_t pcIdx = 0;
    uint32_t addPad = ((imgCols * 3) % 4);
    if (addPad) addPad = 4 - addPad;
    while (pcIdx < pointsTotal) {
        uint32_t tmpX = lfsr % imgCols;
        lfsr = (lfsr >> 1) ^ (-(lfsr & 1u) & 0xD0000001u);
        uint32_t tmpY = lfsr % (imgRows - 2);
        lfsr = (lfsr >> 1) ^ (-(lfsr & 1u) & 0xD0000001u);
        uint32_t randPixBase = (tmpY * imgCols * 3) + (tmpX * 3);
        randPixBase += (tmpY * addPad);
        uint8_t pixRed = imgData[randPixBase];
        uint8_t pixGrn = imgData[randPixBase+1];
        uint8_t pixBlu = imgData[randPixBase+2];
        uint32_t pcColor = ((((uint32_t)pixBlu) << 16) | (((uint32_t)pixGrn) << 8) | ((uint32_t)pixRed));

        // Use pixel intensity for the Y axis position 
        float pcYval = -((std::abs(((float)(pixRed + pixGrn + pixBlu)))) / 256.0F) + 5.0f;
        ptcData[(pcIdx * 4) + 0] = (((float)tmpX * 10.0F) / imgCols) - 5.0F;    // X
        ptcData[(pcIdx * 4) + 1] = pcYval;                                      // Y
        ptcData[(pcIdx * 4) + 2] = (((float)tmpY * 10.0F) / imgRows);           // Z
        ptcData[(pcIdx * 4) + 3] = *reinterpret_cast<float*>(&pcColor);;        // Color
        pcIdx++;
       
    }
}

/**
 * cart_to_sphere()
 * convert cartesion(x,y,z) to spherical(rad, pol, azi) coordinates
 */
void cart_to_sphere(Vec3d_t &cart, Vec3d_t &sphere_rpa)
{
    sphere_rpa.x = sqrt(pow(cart.x, 2.0) + pow(cart.y, 2.0) +pow(cart.z, 2.0));
    sphere_rpa.y = acos(cart.z / sphere_rpa.x);
    sphere_rpa.z = atan2(cart.y, cart.x);
}

/**
 * sphere_to_cart()
 * convert spherical(rad, pol, azi) to cartesion(x,y,z) coordinates
 */
void sphere_to_cart(Vec3d_t &sphere_rpa, Vec3d_t &cart)
{
    cart.x = sphere_rpa.x * sin(sphere_rpa.y) * cos(sphere_rpa.z);
    cart.y = sphere_rpa.x * sin(sphere_rpa.y) * sin(sphere_rpa.z);
    cart.z = sphere_rpa.x * cos(sphere_rpa.y);
}

/***
 * pose_marker_update
 */
void pose_marker_update(std::vector<PoseMarkerInfo> &poseMarks)
{
    for(int i=0 ; i<poseMarks.size() ; i++) {
        Vec3d_t rpaPos;
        // convert to spherical coordinates
        cart_to_sphere(poseMarks.at(i).position, rpaPos);

        // rotate around Z by changing azimuth
        rpaPos.z += (0.15 * (1.0 - (rpaPos.x/10.0)));

        // get the marker to point to its motion
        double yaw = rpaPos.z + (3.141592653 / 2);
        double roll = 0.0;
        double pitch = 0.0;
        double cr = cos(roll * 0.5);
        double sr = sin(roll * 0.5);
        double cp = cos(pitch * 0.5);
        double sp = sin(pitch * 0.5);
        double cy = cos(yaw * 0.5);
        double sy = sin(yaw * 0.5);

        poseMarks.at(i).orientation.w = cr * cp * cy + sr * sp * sy;
        poseMarks.at(i).orientation.x = sr * cp * cy - cr * sp * sy;
        poseMarks.at(i).orientation.y = cr * sp * cy + sr * cp * sy;
        poseMarks.at(i).orientation.z = cr * cp * sy - sr * sp * cy;        

        // back to cartesian
        sphere_to_cart(rpaPos, poseMarks.at(i).position);
    }
}   

/***
 * poly_sample_update
 * Update the contents of the polygon sample
 */
void poly_sample_update(geometry_msgs::msg::dds_::PolygonStamped_ &poly_sample)
{
    // initial values of the points (x,y,z)
    float ppoints[] = {
        -5.0f,  5.0f, 10.0f,
        -5.0f,  5.0f,  0.0f,
        -5.0f, -5.0f,  0.0f,
        -5.0f, -5.0f, 10.0f,
        -5.0f,  5.0f, 10.0f,
         5.0f,  5.0f, 10.0f,
         5.0f, -5.0f, 10.0f,
         5.0f, -5.0f,  0.0f,
         5.0f,  5.0f,  0.0f,
         5.0f,  5.0f, 10.0f
    };
    for(int i=0; i<poly_sample.polygon().points().size() ; i++) {
        ppoints[(i*3)+0] += randFloatInRange(-0.03f, 0.03f);
        poly_sample.polygon().points().at(i).x(ppoints[(i*3)+0]);

        ppoints[(i*3)+1] += randFloatInRange(-0.03f, 0.03f);
        poly_sample.polygon().points().at(i).y(ppoints[(i*3)+1]);

        ppoints[(i*3)+2] += randFloatInRange(-0.03f, 0.03f);
        poly_sample.polygon().points().at(i).z(ppoints[(i*3)+2]);
    }
}

/** ----------------------------------------------------------------
 * participant_main()
 **/
void participant_main(int domain_id)
{
    // Create a DomainParticipant and a Publisher with default Qos
    dds::domain::DomainParticipant participant(domain_id);
    dds::pub::Publisher publisher(participant);
    timespec ts;

    // PointCloud2: create topic, datawriter, initialized sample
    dds::topic::Topic<sensor_msgs::msg::dds_::PointCloud2_> ptcloud2_topic(participant, "rt/lidar_points");
    dds::pub::qos::DataWriterQos ptcloud2_dw_qos = dds::core::QosProvider::Default().datawriter_qos();
    ptcloud2_dw_qos.policy<rti::core::policy::Property>().set({ "dds.data_writer.history.memory_manager.fast_pool.pool_buffer_max_size", "1048576" });
    dds::pub::DataWriter<sensor_msgs::msg::dds_::PointCloud2_> ptcloud2_dw(publisher, ptcloud2_topic, ptcloud2_dw_qos);
    sensor_msgs::msg::dds_::PointCloud2_ ptcloud2_sample;
    uint32_t ptc_width = 200;
    uint32_t ptc_height = 5;
    uint32_t ptc_bpp = 16;                      // bytes per point
    ptcloud2_sample.is_dense(true);
    ptcloud2_sample.is_bigendian(false);
    ptcloud2_sample.header().frame_id("map");
    ptcloud2_sample.width(ptc_width);
    ptcloud2_sample.height(ptc_height);
    ptcloud2_sample.point_step(ptc_bpp);
    ptcloud2_sample.row_step(ptc_bpp * ptc_width);
    ptcloud2_sample.data().resize(ptc_bpp * ptc_width * ptc_height);
    ptcloud2_sample.fields().resize(4);         // 'PointField' describes the points in .data()
    ptcloud2_sample.fields().at(0).name("x");
    ptcloud2_sample.fields().at(0).offset(0);
    ptcloud2_sample.fields().at(0).datatype(7);  // 2=UINT8, 7=float32
    ptcloud2_sample.fields().at(0).count(1);
    ptcloud2_sample.fields().at(1).name("y");
    ptcloud2_sample.fields().at(1).offset(4);
    ptcloud2_sample.fields().at(1).datatype(7);
    ptcloud2_sample.fields().at(1).count(1);
    ptcloud2_sample.fields().at(2).name("z");
    ptcloud2_sample.fields().at(2).offset(8);
    ptcloud2_sample.fields().at(2).datatype(7);
    ptcloud2_sample.fields().at(2).count(1);
    ptcloud2_sample.fields().at(3).name("rgb");
    ptcloud2_sample.fields().at(3).offset(12);
    ptcloud2_sample.fields().at(3).datatype(7);
    ptcloud2_sample.fields().at(3).count(1);
    float *ptcData = reinterpret_cast<float *>(ptcloud2_sample.data().data());
    uint32_t pointsTotal = 200 * 5;

    // OccupancyGrid (Map): shows up on the floor grid in RViz
    dds::topic::Topic<nav_msgs::msg::dds_::OccupancyGrid_> ogrid_topic(participant, "rt/floor_map");
    dds::pub::qos::DataWriterQos ogrid_dw_qos = dds::core::QosProvider::Default().datawriter_qos();
    ogrid_dw_qos.policy<rti::core::policy::Property>().set({ "dds.data_writer.history.memory_manager.fast_pool.pool_buffer_max_size", "10240" });
    dds::pub::DataWriter<nav_msgs::msg::dds_::OccupancyGrid_> ogrid_dw(publisher, ogrid_topic, ogrid_dw_qos);
    nav_msgs::msg::dds_::OccupancyGrid_ ogrid_sample;
    int ogridRows = 96;     // 96x96=9216 (max size set in IDL file)
    int ogridCols = 96;
    ogrid_sample.info().width(ogridRows);
    ogrid_sample.info().height(ogridCols);
    ogrid_sample.data().resize(ogridRows * ogridCols);
    ogrid_sample.info().resolution(10.0f / static_cast<float>(ogridCols));
    ogrid_sample.info().origin().position().x(-5.0f);
    ogrid_sample.info().origin().position().y(-5.0f);
    ogrid_sample.info().origin().position().z(0.0f);
    ogrid_sample.info().origin().orientation().w(PI_F);
    ogrid_sample.header().frame_id("map");


    // Image data type
    dds::topic::Topic<sensor_msgs::msg::dds_::Image_> image_topic(participant, "rt/cam_image");
    dds::pub::qos::DataWriterQos image_dw_qos = dds::core::QosProvider::Default().datawriter_qos();
    image_dw_qos.policy<rti::core::policy::Property>().set({ "dds.data_writer.history.memory_manager.fast_pool.pool_buffer_max_size", "1048576" });
    dds::pub::DataWriter<sensor_msgs::msg::dds_::Image_> image_dw(publisher, image_topic, image_dw_qos);
    sensor_msgs::msg::dds_::Image_ image_sample;
    int image_xres = 320;
    int image_yres = 200;
    image_sample.height(image_yres);
    image_sample.width(image_xres);
    image_sample.step(image_xres * 3);
    image_sample.data().resize(image_xres * image_yres * 3);
    image_sample.encoding("bgr8");
    image_sample.is_bigendian(false);
    image_sample.header().frame_id("map");


    // PoseStamped: post a single sample
    dds::topic::Topic<geometry_msgs::msg::dds_::PoseStamped_> pose_stamped_topic(participant, "rt/pose_val");
    dds::pub::DataWriter<geometry_msgs::msg::dds_::PoseStamped_> pose_stamped_dw(publisher, pose_stamped_topic);
    geometry_msgs::msg::dds_::PoseStamped_ pose_stamped_sample;
    pose_stamped_sample.header().frame_id("map");
    pose_stamped_sample.pose().position().x(0.0f);
    pose_stamped_sample.pose().position().y(0.0f);
    pose_stamped_sample.pose().position().z(3.0f);
    tstamp_get(&ts);
    pose_stamped_sample.header().stamp().sec((int32_t)ts.tv_sec);
    pose_stamped_sample.header().stamp().nanosec(ts.tv_nsec);
    pose_stamped_dw.write(pose_stamped_sample);

    // keep posearray and markerarray positions in vector
    const int32_t poses_max = 10;
    std::vector<PoseMarkerInfo> poseMarks;
    poseMarks.resize(poses_max);
    for(int n=0 ; n<poses_max ; n++) {
        poseMarks.at(n).position.x = randDoubleInRange(-4.3, 4.3);
        poseMarks.at(n).position.y = randDoubleInRange(-4.3, 4.3);
        poseMarks.at(n).position.z = randDoubleInRange( 0.0, 9.0);
        poseMarks.at(n).orientation.x = 0.0f;
        poseMarks.at(n).orientation.y = 0.0f;
        poseMarks.at(n).orientation.z = 0.0f;
        poseMarks.at(n).orientation.w = 1.0f;
        poseMarks.at(n).label = std::string("Node" + std::to_string(n));
    }

    dds::topic::Topic<geometry_msgs::msg::dds_::PoseArray_> pose_array_topic(participant, "rt/pose_vals");
    dds::pub::qos::DataWriterQos pose_array_dw_qos = dds::core::QosProvider::Default().datawriter_qos();
    pose_array_dw_qos.policy<rti::core::policy::Property>().set({ "dds.data_writer.history.memory_manager.fast_pool.pool_buffer_max_size", "10240" });
    dds::pub::DataWriter<geometry_msgs::msg::dds_::PoseArray_> pose_array_dw(publisher, pose_array_topic, pose_array_dw_qos);
    geometry_msgs::msg::dds_::PoseArray_ pose_array_sample;
    pose_array_sample.poses().resize(poses_max);
    pose_array_sample.header().frame_id("map");


    // 'Marker' data type
    dds::topic::Topic<visualization_msgs::msg::dds_::Marker_> marker_topic(participant, "rt/test_mark");
    dds::pub::qos::DataWriterQos marker_dw_qos = dds::core::QosProvider::Default().datawriter_qos();
    marker_dw_qos.policy<rti::core::policy::Property>().set({ "dds.data_writer.history.memory_manager.fast_pool.pool_buffer_max_size", "10240" });
    dds::pub::DataWriter<visualization_msgs::msg::dds_::Marker_> marker_dw(publisher, marker_topic, marker_dw_qos);
    visualization_msgs::msg::dds_::Marker_ marker_sample;
    marker_sample.header().frame_id("map");
    marker_sample.ns("rti");
    marker_sample.id(0);
    marker_sample.type(0);
    marker_sample.action(0);
    marker_sample.scale().x(0.2);
    marker_sample.scale().y(0.2);
    marker_sample.scale().z(0.2);
    marker_sample.color().r(0.0);
    marker_sample.color().g(1.0);
    marker_sample.color().b(0.0);
    marker_sample.color().a(1.0);
    marker_sample.lifetime().sec(3);
    marker_sample.lifetime().nanosec(0);
    marker_sample.pose().position().x(0.0f);
    marker_sample.pose().position().y(0.0f);
    marker_sample.pose().position().z(2.0f);
    marker_sample.text("Marker");
    tstamp_get(&ts);
    marker_sample.header().stamp().sec((int32_t)ts.tv_sec);
    marker_sample.header().stamp().nanosec(ts.tv_nsec);
    marker_dw.write(marker_sample);


    // 'MarkerArray' data type
    dds::topic::Topic<visualization_msgs::msg::dds_::MarkerArray_> marker_array_topic(participant, "rt/test_markers");
    dds::pub::qos::DataWriterQos marker_array_dw_qos = dds::core::QosProvider::Default().datawriter_qos();
    marker_array_dw_qos.policy<rti::core::policy::Property>().set({ "dds.data_writer.history.memory_manager.fast_pool.pool_buffer_max_size", "61440" });
    dds::pub::DataWriter<visualization_msgs::msg::dds_::MarkerArray_> marker_array_dw(publisher, marker_array_topic, marker_array_dw_qos);
    visualization_msgs::msg::dds_::MarkerArray_ marker_array_sample;
    int32_t markers_max = poses_max;
    marker_array_sample.markers().resize(markers_max);
    visualization_msgs::msg::dds_::Marker_ *maBase = marker_array_sample.markers().data();
    std::vector<std::string> markers_labels = {"DDS", "RTI", "UDPv4", "DPDE", "DPSE", "ZeroCopy", "26262", "Scale", "ROS2", "Speed"};
    // init the markers (some items use common values)
    for (int m = 0; m < markers_max; m++) {
        maBase[m].header().frame_id("map");
        maBase[m].ns("rti");
        maBase[m].id(m);
#if 0   // use an STL shape marker (from file)
        maBase[m].type(visualization_msgs::msg::dds_::Marker_Constants::MESH_RESOURCE_);
        maBase[m].mesh_resource(std::string("file:///home/this-project-path/src/rviz_demo/img/rtilogo.stl"));
        maBase[m].scale().x(0.006);
        maBase[m].scale().y(0.006);
        maBase[m].scale().z(0.006);
#else   // use a text marker
        maBase[m].type(visualization_msgs::msg::dds_::Marker_Constants::TEXT_VIEW_FACING_);
        maBase[m].scale().x(0.2);
        maBase[m].scale().y(0.2);
        maBase[m].scale().z(0.2);
        maBase[m].text(markers_labels.at(m));
#endif        
        maBase[m].pose().orientation().w(0.5f);
        maBase[m].pose().orientation().x(0.6f);
        maBase[m].action(visualization_msgs::msg::dds_::Marker_Constants::ADD_);
        maBase[m].color().r(0.0F);
        maBase[m].color().g(0.3F);
        maBase[m].color().b(1.0F);
        maBase[m].color().a(1.0F);
        maBase[m].lifetime().sec(30);
    }

    // 'Odometry' data type
    dds::topic::Topic<nav_msgs::msg::dds_::Odometry_> odometry_topic(participant, "rt/test_odom");
    dds::pub::DataWriter<nav_msgs::msg::dds_::Odometry_> odometry_dw(publisher, odometry_topic);
    nav_msgs::msg::dds_::Odometry_ odometry_sample;
    const int32_t odom_max = poses_max;
    odometry_sample.header().frame_id("map");
    odometry_sample.child_frame_id("map");
    odometry_sample.pose().pose().position().x(-1.0);
    odometry_sample.pose().pose().position().y(-1.0);
    odometry_sample.pose().pose().position().z(1.0);
    odometry_sample.pose().pose().orientation().w(1.0);
    odometry_sample.pose().pose().orientation().x(0.0);
    odometry_sample.pose().pose().orientation().y(0.0);
    odometry_sample.pose().pose().orientation().z(0.0);
    tstamp_get(&ts);
    odometry_sample.header().stamp().sec((int32_t)ts.tv_sec);
    odometry_sample.header().stamp().nanosec(ts.tv_nsec);
    odometry_dw.write(odometry_sample);


    // 'Path' data type
    dds::topic::Topic<nav_msgs::msg::dds_::Path_> path_topic(participant, "rt/test_path");
    dds::pub::qos::DataWriterQos path_dw_qos = dds::core::QosProvider::Default().datawriter_qos();
    path_dw_qos.policy<rti::core::policy::Property>().set({ "dds.data_writer.history.memory_manager.fast_pool.pool_buffer_max_size", "61440" });
    dds::pub::DataWriter<nav_msgs::msg::dds_::Path_> path_dw(publisher, path_topic, path_dw_qos);
    nav_msgs::msg::dds_::Path_ path_sample;
    const int32_t path_max = poses_max;
    path_sample.poses().resize(path_max);
    path_sample.header().frame_id("map");
    for (int32_t i = 0; i < path_max; i++) {
        path_sample.poses().at(i).pose().position().x(-2.0 + ((double)i / 10));
        path_sample.poses().at(i).pose().position().y(-2.0 + ((double)i / 10));
        path_sample.poses().at(i).pose().position().z( 2.0 + ((double)i / 10));
    }
    tstamp_get(&ts);
    path_sample.header().stamp().sec((int32_t)ts.tv_sec);
    path_sample.header().stamp().nanosec(ts.tv_nsec);
    path_dw.write(path_sample);


    // 'FluidPressure' data type
    dds::topic::Topic<sensor_msgs::msg::dds_::FluidPressure_> fluid_pressure_topic(participant, "rt/test_pressure");
    dds::pub::DataWriter<sensor_msgs::msg::dds_::FluidPressure_> fluid_pressure_dw(publisher, fluid_pressure_topic);
    sensor_msgs::msg::dds_::FluidPressure_ fluid_pressure_sample;
    fluid_pressure_sample.header().frame_id("map");
    fluid_pressure_sample.fluid_pressure(12.345);
    fluid_pressure_sample.variance(0.04);
    tstamp_get(&ts);
    fluid_pressure_sample.header().stamp().sec((int32_t)ts.tv_sec);
    fluid_pressure_sample.header().stamp().nanosec(ts.tv_nsec);
    fluid_pressure_dw.write(fluid_pressure_sample);


    // 'PolygonStamped_' data type
    dds::topic::Topic<geometry_msgs::msg::dds_::PolygonStamped_> poly_topic(participant, "rt/test_poly");
    dds::pub::qos::DataWriterQos poly_dw_qos = dds::core::QosProvider::Default().datawriter_qos();
    poly_dw_qos.policy<rti::core::policy::Property>().set({ "dds.data_writer.history.memory_manager.fast_pool.pool_buffer_max_size", "61440" });
    dds::pub::DataWriter<geometry_msgs::msg::dds_::PolygonStamped_> poly_dw(publisher, poly_topic, poly_dw_qos);
    geometry_msgs::msg::dds_::PolygonStamped_ poly_sample;
    const int32_t poly_max = poses_max;
    poly_sample.polygon().points().resize(poly_max);
    poly_sample.header().frame_id("map");
    poly_sample_update(poly_sample);
    tstamp_get(&ts);
    poly_sample.header().stamp().sec((int32_t)ts.tv_sec);
    poly_sample.header().stamp().nanosec(ts.tv_nsec);
    poly_dw.write(poly_sample);

    // PointCloud data will be taken from an image file
    int maxImgCount = 6;
    const char *imgFileList[6];
    imgFileList[0] = "./src/rviz_demo/img/L1.bmp";
    imgFileList[1] = "./src/rviz_demo/img/L2.bmp";
    imgFileList[2] = "./src/rviz_demo/img/L3.bmp";
    imgFileList[3] = "./src/rviz_demo/img/L4.bmp";
    imgFileList[4] = "./src/rviz_demo/img/L5.bmp";
    imgFileList[5] = "./src/rviz_demo/img/L6.bmp";

    uint32_t imgRows = 0;
    uint32_t imgCols = 0;
    uint8_t *imgData = NULL;
    geometry_msgs::msg::dds_::Pose_ *poseData = pose_array_sample.poses().data();
    int imgIdx = 0;

    // main loop --------------------------------------------------------------
    for (int wcount = 0; 1; wcount++) {

        if (!(wcount % 200)) {
            if (imgData) {
                free(imgData);
            }
            if (read_ptcloud_bitmap(&imgData, &imgRows, &imgCols, imgFileList[imgIdx])) {
                fprintf(stderr, "ERROR: Cannot open file (%s:%d)\n", __FILE__, __LINE__);
                return;
            }
            if (++imgIdx >= maxImgCount) {
                imgIdx = 0;
            }
            // scale the image and send on ROS2 'OccupancyGrid' 
            ogrid_scale_image(imgData, imgCols, imgRows, ogrid_sample.data().data(), ogridRows, ogridCols);
            tstamp_get(&ts);
            ogrid_sample.header().stamp().sec((int32_t)ts.tv_sec);
            ogrid_sample.header().stamp().nanosec(ts.tv_nsec);
            ogrid_dw.write(ogrid_sample);

            // send scaled image to ROS2 'Image' type data topic
            image_scale_image(imgData, imgCols, imgRows, image_sample.data().data(), image_xres, image_yres);
            tstamp_get(&ts);
            image_sample.header().stamp().sec((int32_t)ts.tv_sec);
            image_sample.header().stamp().nanosec(ts.tv_nsec);
            image_dw.write(image_sample);

        }

        if (!(wcount % 2)) {
            // send the marker
            float tmpRndX = (((float)(rand() % 1000)) / 100) - 5.0F;
            float tmpRndY = (((float)(rand() % 1000)) / 100) - 5.0F;
            float tmpRndZ = (((float)(rand() % 1000)) / 100);
            uint32_t tmpRndV = rand() % 1000;
            marker_sample.pose().position().x(tmpRndX);
            marker_sample.pose().position().y(tmpRndY);
            marker_sample.pose().position().z(tmpRndZ);
            char tmpStr[9];
            sprintf(tmpStr, "MK%04u", tmpRndV);
            marker_sample.text(tmpStr);
            marker_sample.id(wcount);
            tstamp_get(&ts);
            marker_sample.header().stamp().sec((int32_t)ts.tv_sec);
            marker_sample.header().stamp().nanosec(ts.tv_nsec);
            marker_dw.write(marker_sample);

            // Path
            for (int32_t i = 0; i < path_max; i++) {
                path_sample.poses().at(i).pose().position().x(randDoubleInRange( -3.0, -2.0));
                path_sample.poses().at(i).pose().position().y(randDoubleInRange( -3.0, -2.0));
                path_sample.poses().at(i).pose().position().z(randDoubleInRange( 0.0, 1.0));
            }
            tstamp_get(&ts);
            path_sample.header().stamp().sec((int32_t)ts.tv_sec);
            path_sample.header().stamp().nanosec(ts.tv_nsec);
            path_dw.write(path_sample);

            fluid_pressure_sample.fluid_pressure(randDoubleInRange(12.00, 13.00));
            tstamp_get(&ts);
            fluid_pressure_sample.header().stamp().sec((int32_t)ts.tv_sec);
            fluid_pressure_sample.header().stamp().nanosec(ts.tv_nsec);
            fluid_pressure_dw.write(fluid_pressure_sample);

            // update the pose
            pose_stamped_sample.pose().position().x(randDoubleInRange( -1.0, 1.0));
            pose_stamped_sample.pose().position().y(randDoubleInRange( -1.0, 1.0));
            pose_stamped_sample.pose().position().z(randDoubleInRange( 0.0, 1.0));
            tstamp_get(&ts);
            pose_stamped_sample.header().stamp().sec((int32_t)ts.tv_sec);
            pose_stamped_sample.header().stamp().nanosec(ts.tv_nsec);
            pose_stamped_dw.write(pose_stamped_sample);

            // polygon
            poly_sample_update(poly_sample);
            tstamp_get(&ts);
            poly_sample.header().stamp().sec((int32_t)ts.tv_sec);
            poly_sample.header().stamp().nanosec(ts.tv_nsec);            
            poly_dw.write(poly_sample);

            // odometrry
            odometry_sample.pose().pose().position().x(randDoubleInRange( 1.0, 2.0));
            odometry_sample.pose().pose().position().y(randDoubleInRange( -2.0, -1.0));
            odometry_sample.pose().pose().position().z(randDoubleInRange( 1.0, 2.0));
            tstamp_get(&ts);
            odometry_sample.header().stamp().sec((int32_t)ts.tv_sec);
            odometry_sample.header().stamp().nanosec(ts.tv_nsec);
            odometry_dw.write(odometry_sample);


            // update the posearray and markerarray positions
            pose_marker_update(poseMarks);
            tstamp_get(&ts);
            for (int k = 0; k < poses_max; k++) {
                //tmpRndX = (((float)(rand() % 1000)) / 100) - 5.0F;
                //tmpRndY = (((float)(rand() % 1000)) / 100) - 5.0F;
                //tmpRndZ = (((float)(rand() % 1000)) / 100);
                tmpRndX = poseMarks.at(k).position.x;
                tmpRndY = poseMarks.at(k).position.y;
                tmpRndZ = poseMarks.at(k).position.z;
                // pose array
                pose_array_sample.poses().at(k).position().x((double)tmpRndX);
                pose_array_sample.poses().at(k).position().y((double)tmpRndY);
                pose_array_sample.poses().at(k).position().z((double)tmpRndZ);
                pose_array_sample.poses().at(k).orientation().w(poseMarks.at(k).orientation.w);
                pose_array_sample.poses().at(k).orientation().x(poseMarks.at(k).orientation.x);
                pose_array_sample.poses().at(k).orientation().y(poseMarks.at(k).orientation.y);
                pose_array_sample.poses().at(k).orientation().z(poseMarks.at(k).orientation.z);
                // markers
                maBase[k].pose().position().x((double)tmpRndX);
                maBase[k].pose().position().y((double)tmpRndY);
                maBase[k].pose().position().z((double)tmpRndZ + 0.2);
                maBase[k].action(visualization_msgs::msg::dds_::Marker_Constants::MODIFY_);
                maBase[k].header().stamp().sec((int32_t)ts.tv_sec);
                maBase[k].header().stamp().nanosec(ts.tv_nsec);
            }
            pose_array_sample.header().stamp().sec((int32_t)ts.tv_sec);
            pose_array_sample.header().stamp().nanosec(ts.tv_nsec);
            pose_array_dw.write(pose_array_sample);
            marker_array_dw.write(marker_array_sample);
        }
        // use the image data as a source of pointcloud points, selected randomly
        ptcloud_build_img_export(imgData, imgRows, imgCols, (ptc_width * ptc_height), ptcData);
        tstamp_get(&ts);
        ptcloud2_sample.header().stamp().sec((int32_t)ts.tv_sec);
        ptcloud2_sample.header().stamp().nanosec(ts.tv_nsec);
        ptcloud2_dw.write(ptcloud2_sample);

        rti::util::sleep(dds::core::Duration(0, 100000000));
    }
}

/** ----------------------------------------------------------------
 * main()
 **/
int main(int argc, char *argv[])
{
    int domain_id = 0;

    if (argc >= 2) {
        domain_id = atoi(argv[1]);
    }

    // To turn on additional logging, include <rti/config/Logger.hpp> and
    // uncomment the following line:
    // rti::config::Logger::instance().verbosity(rti::config::Verbosity::STATUS_ALL);

    try {
        participant_main(domain_id);
    }
    catch (const std::exception& ex) {
        // This will catch DDS exceptions
        std::cerr << "Exception in participant_main(): " << ex.what() << std::endl;
        return -1;
    }

    // RTI Connext provides a finalize_participant_factory() method
    // if you want to release memory used by the participant factory singleton.
    // Uncomment the following line to release the singleton:
    //
    // dds::domain::DomainParticipant::finalize_participant_factory();

    return 0;
}

