/*
* (c) Copyright, Real-Time Innovations, 2012.  All rights reserved.
* RTI grants Licensee a license to use, modify, compile, and create derivative
* works of the software solely for use with RTI Connext DDS. Licensee may
* redistribute copies of the software provided that all such copies are subject
* to this license. The software is provided "as is", with no warranty of any
* type, including any warranty for fitness for any purpose. RTI is under no
* obligation to maintain or support the software. RTI shall not be liable for
* any incidental or consequential damages arising out of the use or inability
* to use the software.
*/

/** ================================================================
 * turtle_shapes.cxx
 * Derived from code automatically generated by the rtiddsgen command:
 *  rtiddsgen -language C++11 -example <arch> cros2_types.idl
 *
 * This example will subscribe to ShapeTypeExtended data (from Shapes Demo),
 * and the turtlesim 'Pose' data, to create and publish commands to move
 * or teleport the turtle in TurtleSim, plus a position-feedback topic
 * using ShapeType Triangle.
 **/

#include <algorithm>
#include <iostream>
#include <list>
#include <cmath>
#include <dds/pub/ddspub.hpp>
#include <dds/sub/ddssub.hpp>
#include <dds/core/ddscore.hpp>
#include <rti/util/util.hpp> // for sleep()
#include "cros2_turtlesim_support.hpp"
#include "shapesdemo_support.hpp"
#include <stdio.h>

const int ShapeColorCount = 8;
const double halfPi = 1.570796327;
const double onePi  = 3.141592654;
const double twoPi  = 6.283185307;
const float STperX = 240.0f / 11.0f;     // ShapeType grids per TurtleSim grids: X
const float STperY = 270.0f / 11.0f;     // ShapeType grids per TurtleSim grids: Y

/** A note about turtlesim screen:
    11.0 x 11.0 = onscreen position information (reported by turtle)
     480 x 480  = onscreen pixels
    1 px = 0.02292 xy coord 
 **/


/** ----------------------------------------------------------------
 * participant_main()
 *  - Subscribe to "Square" ShapeType (from Shapes Demo) & spawn a 
 *    turtle (in ROS2 turtlesim) for each color.  Move the turtle
 *    using the "teleport absolute" Service(SRV) in turtlesim.
 *  - Subscribe to "Circle" ShapeType & spawn a turtle for each color.
 *    Move the turtle using the "Twist" message(MSG) in turtlesim.
 *    This method is less accurate than teleport, so this will also
 *    subscribe to the "Pose" of the turtle to report actual position,
 *    which will be published as a ShapeType "Triangle" in the same color.
 **/
void participant_main(int domain_id, int sample_count)
{
    // Create a DomainParticipant with default Qos
    dds::domain::DomainParticipant participant(domain_id);

    // instantiate shapesdemo interop class to subscribe to Square & Circle, and publish Triangle
    shapesdemo mySquare(std::string("Square"), (1 << SHAPESDEMO_SUB_ON), participant);
    shapesdemo myCircle(std::string("Circle"), (1 << SHAPESDEMO_SUB_ON), participant);
    shapesdemo myTriangle(std::string("Triangle"), (1 << SHAPESDEMO_PUB_ON), participant);
    rcv_shape_t *squares = mySquare.get_shape_array();
    rcv_shape_t *circles = myCircle.get_shape_array();

    // instantiate a turtlesim interop class, and pointers to individual turtles
    turtleapp myTurtleApp(participant);
    turtleinst *squareTurtles[ShapeColorCount] = { NULL };
    turtleinst *circleTurtles[ShapeColorCount] = { NULL };

    // some mappings to colors and names
    uint32_t lineColors[ShapeColorCount] = {0x800080, 0xff, 0xff0000, 0xff00, 0xffff00, 0xffff, 0xff00ff, 0xffaa00};

    // remove the default turtle
    myTurtleApp.retire_turtle("turtle1");
    rti::util::sleep(dds::core::Duration(1));

    uint32_t opt_en = ((1 << MOVE_PUB) | (1 << TELEPORT_ABS) | (1 << PEN_SET) | (1 << POSE_SUB));
    float sX, sY;
    double DerivET = 0;
    double PrevET = 0;
    double DerivEP = 0;
    double PrevEP = 0;
    double Kp_T = 9.0;      // Proportional gain for Theta (turn the turtle)
    double Kd_T = 2.5;      // Derivative   gain for Theta (turn)
    double Kp_P = 6.0;      // Proportional gain for Position
    double Kd_P = 0.5;      // Derivative   gain for position



    // main loop --------------------------------------------------------------
    // 
    while(1) {
        // check the waitset list for received shapes data
        mySquare.datarcv_waitset(0, 10000000);
        myCircle.datarcv_waitset(0, 10000000);

        // check the turtles
        for (int i = 0; i < ShapeColorCount; i++) {
            // square turtles: use Teleport (SRV) to move turtle
            if (squareTurtles[i] != NULL) {
                if (squares[i].isNew) {
                    sX = ((float)squares[i].x) / STperX;
                    sY = ((float)(270 - squares[i].y)) / STperY;
                    squareTurtles[i]->turtle_teleport_xy(sX, sY, (squares[i].angle - 180.0f) / -57.29578f);
                    squares[i].isNew = false;
                }
            }
            else {
                if (squares[i].isNew) {
                    // spawn a turtle for this shape color
                    std::string newTurtleName("Square" + squares[i].color);
                    sX = ((float)squares[i].x) / STperX;
                    sY = ((float)(270 - squares[i].y)) / STperY;
                    myTurtleApp.spawn_turtle(newTurtleName, sX, sY);
                    squareTurtles[i] = new turtleinst(newTurtleName, opt_en, participant);
                    squareTurtles[i]->turtle_pen_set(lineColors[i]);
                    squareTurtles[i]->turtle_pen_set(static_cast<uint8_t>(1));
                    squareTurtles[i]->datarcv_waitset(0, 100000000);
                    myTurtleApp.datarcv_waitset(0, 100000000);
                    squares[i].isNew = false;
                }
            }
            // circle turtles: use Twist (MSG) to move turtle
            if (circleTurtles[i] != NULL) {
                if (circles[i].isNew) {
                    // Get the circle position, convert to turtle coords(11x11))
                    sX = ((float)circles[i].x) / STperX;
                    sY = ((float)(270 - circles[i].y)) / STperY;

                    // find the position and direction(theta) error between circle and turtle
                    double ErrX = sX - circleTurtles[i]->myPose.x;
                    double ErrY = sY - circleTurtles[i]->myPose.y;
                    double ErrorP = sqrt(pow(ErrX, 2.0) + pow(ErrY, 2.0));
                    double ErrTheta = atan2(ErrY, ErrX);
                    ErrTheta -= circleTurtles[i]->myPose.theta;
                    if ((ErrTheta > halfPi) && (circleTurtles[i]->myPose.theta < -halfPi)) {
                        ErrTheta -= twoPi;
                    }
                    if ((ErrTheta < -halfPi) && (circleTurtles[i]->myPose.theta > halfPi)) {
                        ErrTheta += twoPi;
                    }

                    // Use a PD control for turning and accelerating the turtle
                    DerivET = ErrTheta - PrevET;
                    PrevET = ErrTheta;
                    double turn = (ErrTheta * Kp_T) + (DerivET * Kd_T);

                    DerivEP = ErrorP - PrevEP;
                    PrevEP = ErrorP;
                    double fwd = sqrt(pow(circleTurtles[i]->myPose.x - sX, 2.0) + pow(circleTurtles[i]->myPose.y - sY, 2.0));
                    fwd = (fwd * Kp_P) + (DerivEP * Kd_P);
                    circleTurtles[i]->turtle_move_and_turn(fwd, turn);
                    circles[i].isNew = false;

                    // publish the position as a Triangle 
                    int32_t tri_x = static_cast<int32_t>(circleTurtles[i]->myPose.x * STperX);
                    int32_t tri_y = static_cast<int32_t>(270 - (circleTurtles[i]->myPose.y * STperY));
                    myTriangle.pub_sample_xysize_set(tri_x, tri_y, 8);
                    myTriangle.publish();

                }
            }
            else {
                if (circles[i].isNew) {
                    // spawn a turtle for this shape color
                    std::string newTurtleName("Circle" + circles[i].color);
                    sX = ((float)circles[i].x) / STperX;
                    sY = ((float)(270 - circles[i].y)) / STperY;
                    myTurtleApp.spawn_turtle(newTurtleName, sX, sY);
                    circleTurtles[i] = new turtleinst(newTurtleName, opt_en, participant);
                    circleTurtles[i]->turtle_pen_set(lineColors[i]);
                    circleTurtles[i]->turtle_pen_set(static_cast<uint8_t>(1));
                    circleTurtles[i]->datarcv_waitset(0, 100000000);
                    myTurtleApp.datarcv_waitset(0, 100000000);
                    circles[i].isNew = false;
                }
            }

        }

        // check for received data from the turtles
        for (int i = 0; i < ShapeColorCount; i++) {
            if (circleTurtles[i] != NULL) {
                circleTurtles[i]->datarcv_waitset(0, 100000000);
            }
            if (squareTurtles[i] != NULL) {
                squareTurtles[i]->datarcv_waitset(0, 100000000);
            }
        }

        //rti::util::sleep(dds::core::Duration(0, 20000000));

    }
}

int main(int argc, char *argv[])
{

    int domain_id = 0;
    int sample_count = 0; // infinite loop

    if (argc >= 2) {
        domain_id = atoi(argv[1]);
    }
    if (argc >= 3) {
        sample_count = atoi(argv[2]);
    }

    // To turn on additional logging, include <rti/config/Logger.hpp> and
    // uncomment the following line:
    // rti::config::Logger::instance().verbosity(rti::config::Verbosity::STATUS_ALL);

    try {
        participant_main(domain_id, sample_count);
    }
    catch (const std::exception& ex) {
        // This will catch DDS exceptions
        std::cerr << "Exception in participant_main(): " << ex.what() << std::endl;
        return -1;
    }

    // RTI Connext provides a finalize_participant_factory() method
    // if you want to release memory used by the participant factory singleton.
    // Uncomment the following line to release the singleton:
    //
    // dds::domain::DomainParticipant::finalize_participant_factory();

    return 0;
}

