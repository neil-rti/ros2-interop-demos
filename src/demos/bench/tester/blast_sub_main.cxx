/*
* (c) Copyright, Real-Time Innovations, 2012.  All rights reserved.
* RTI grants Licensee a license to use, modify, compile, and create derivative
* works of the software solely for use with RTI Connext DDS. Licensee may
* redistribute copies of the software provided that all such copies are subject
* to this license. The software is provided "as is", with no warranty of any
* type, including any warranty for fitness for any purpose. RTI is under no
* obligation to maintain or support the software. RTI shall not be liable for
* any incidental or consequential damages arising out of the use or inability
* to use the software.
*/

/** ================================================================
 * blast_sub_main.cxx
 * Subscribes to ROS2 PointCloud2 data type and examines content to
 * check for dropped samples.  Intended for testing of DDS record/replay
 * service applications
 *
 * Uses data type support code generated by the rtiddsgen command:
 *   rtiddsgen -language C++11 cros2_types.idl
 *
 **/

#include <algorithm>
#include <iostream>
#include <array>
#include "cros2_pointcloud_support.hpp"         // for ROS 2 PointCloud2 (LiDAR) pub/sub

// a few globals for convenience.
int         domain_id = 0;                      // DDS domain number
char        topic_name[255] = "ptc_test_0";     // default topic name
uint32_t    tests_run = 0;                      // count of tests run
uint32_t    waitset_delay = 6000000;            // time to spend in waitset
bool        quit_program = false;

// for each topic: a data structure for:
struct data_rcv_stats {
    uint32_t    lowest_sample_number;
    uint32_t    highest_sample_number;
    uint32_t    last_sampnum_received;
    uint32_t    total_samples_received;
    uint32_t    sample_gaps;
} data_stats = { 0xffffffff, 0, 0, 0, 0 };


void print_stats(void)
{
    fprintf(stdout, "low: %u, high: %u, last: %u, total: %u, gaps: %u]\n",
        data_stats.lowest_sample_number,
        data_stats.highest_sample_number,
        data_stats.last_sampnum_received,
        data_stats.total_samples_received,
        data_stats.sample_gaps);
}

/** ----------------------------------------------------------------
 * ptcloud2_benchRcv()
 * Received 'PointCloud2' data handler.
 **/
int ptcloud2_benchRcv(dds::sub::DataReader<sensor_msgs::msg::dds_::PointCloud2_ >& reader)
{
    int count = 0;
    dds::sub::LoanedSamples<sensor_msgs::msg::dds_::PointCloud2_> samples = reader.take();
    for (const auto& sample : samples) {
        if (sample.info().valid()) {
            //printf("Rcv: %u\n", sample.data().data().at(0));
            count++;
            // build the sample number:
            uint32_t sampleNumber = *(uint32_t *)(sample.data().data().data());
            sampleNumber &= 0x3fffff;

            // add to struct
            data_stats.total_samples_received++;
            data_stats.highest_sample_number = sampleNumber;
            if (data_stats.lowest_sample_number == 0xffffffff) {
                data_stats.lowest_sample_number = sampleNumber;
                data_stats.last_sampnum_received = sampleNumber - 1;
            }
            if ((sampleNumber - 1) != data_stats.last_sampnum_received) {
                data_stats.sample_gaps++;
            }
            //print_stats();
            data_stats.last_sampnum_received = sampleNumber;

        }
    }
    tests_run += count;
    return count;
}


/** ----------------------------------------------------------------
 * participant_main()
 **/
void participant_main(void)
{
    // Create a DomainParticipant with default Qos
    dds::domain::DomainParticipant participant(domain_id);

    // Instantiate a subscriber of PointCloud2(LiDAR) and init the sample
    int(*rcv_handler)(dds::sub::DataReader<sensor_msgs::msg::dds_::PointCloud2_>);
    rcv_handler = (int(*)(dds::sub::DataReader<sensor_msgs::msg::dds_::PointCloud2_>))ptcloud2_benchRcv;
    cros2pointcloud myLidarSub(std::string(topic_name), ((uint32_t)1 << CROS2_SUB_ON), participant, rcv_handler);

    // main loop --------------------------------------------------------------
    fprintf(stdout, "READY\n");
    for (int wcount = 0; !quit_program; wcount++) {
        // check for data received
        myLidarSub.datarcv_waitset(0, 300000000);

        if ((data_stats.highest_sample_number) && ((wcount & 0xff) == 0)) {
            print_stats();
        }
    }
}

/** ---------------------------------------------------------------------------
 * errPrintUsage()
 *
 **/
void errPrintUsage(char *progname)
{
    fprintf(stdout, "%s options:\n", progname);
    fprintf(stdout, "-n <name>        Name of data topic(s) (%s)\n", topic_name);
    fprintf(stdout, "-d <0-240>       DDS Domain Number (%d)\n", domain_id);
    fprintf(stdout, "-h               Print this message and exit\n\n");
    return;
}

/** ----------------------------------------------------------------
 * main()
 **/
int main(int argc, char *argv[])
{
    // -------------------------------------------------------------------------
    // parse the args
    int domainNumberIsArg = 0;
    int topicNameIsArg = 0;

    int i = -1;
    int iarg = 1;
    while (iarg < argc)
    {
        if (argv[iarg][0] == '-')
        {
            if ((int)strlen(argv[iarg]) > 1)
            {
                switch (argv[iarg][1])
                {
                case 'd':       // DDS Domain Number (number is the next arg)
                    domainNumberIsArg = iarg + 1;
                    break;

                case 'h':       // print help and exit
                    errPrintUsage(argv[0]);
                    return(-1);

                case 'n':       // DDS topic name to publish
                    topicNameIsArg = iarg + 1;
                    break;

                default:
                    fprintf(stderr, "Invalid option: \"%c\" - Ignored\n", argv[iarg][2]);
                    break;
                }
            }
            iarg++;
        }
        else
        {
            if (domainNumberIsArg == iarg) {
                domain_id = atoi(argv[iarg]);
            }
            else if (topicNameIsArg == iarg) {
                strcpy(topic_name, argv[iarg]);
                topicNameIsArg = 0;
            }
            iarg++;
        }
    }

    // To turn on additional logging, include <rti/config/Logger.hpp> and
    // uncomment the following line:
    // rti::config::Logger::instance().verbosity(rti::config::Verbosity::STATUS_ALL);

    try {
        participant_main();
    }
    catch (const std::exception& ex) {
        // This will catch DDS exceptions
        std::cerr << "Exception in participant_main(): " << ex.what() << std::endl;
        return -1;
    }

    // RTI Connext provides a finalize_participant_factory() method
    // if you want to release memory used by the participant factory singleton.
    // Uncomment the following line to release the singleton:
    //
    //dds::domain::DomainParticipant::finalize_participant_factory();

    return 0;
}

