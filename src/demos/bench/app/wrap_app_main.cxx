/*
* (c) Copyright, Real-Time Innovations, 2012.  All rights reserved.
* RTI grants Licensee a license to use, modify, compile, and create derivative
* works of the software solely for use with RTI Connext DDS. Licensee may
* redistribute copies of the software provided that all such copies are subject
* to this license. The software is provided "as is", with no warranty of any
* type, including any warranty for fitness for any purpose. RTI is under no
* obligation to maintain or support the software. RTI shall not be liable for
* any incidental or consequential damages arising out of the use or inability
* to use the software.
*/

/** ================================================================
 * wrap_app_main.cxx
 * This is a testable application for comparison against a ROS2
 *  implementation of the same functon.
 * Subscribes to ROS2 Float32MultiArray data & immediately converts
 *  and publishes as a ROS2 PointCloud2 data type.
 * Uses data type support code generated by the rtiddsgen command:
 *   rtiddsgen -language C++11 cros2_types.idl
 *
 **/

#include <algorithm>
#include <iostream>
#include "cros2_pointcloud_support.hpp"             // for ROS 2 PointCloud2 (LiDAR) pub/sub

// globals for convenience
cros2pointcloud *lidarPub = NULL;       // publisher
float *ptcData = NULL;                  // pointer to pubs ptcloud data array
uint8_t *pubArray = NULL;               // uint8 pointer to same

 /** ----------------------------------------------------------------
  * ptcloud2_benchRcv()
  * Received 'PointCloud2' data handler.
  **/
int ptcloud2_benchRcv(dds::sub::DataReader<sensor_msgs::msg::dds_::PointCloud2_ >& reader)
{
    int count = 0;
    dds::sub::LoanedSamples<sensor_msgs::msg::dds_::PointCloud2_> samples = reader.take();
    for (const auto& sample : samples) {
        if (sample.info().valid()) {
            *pubArray = sample.data().data().at(0);
            //printf("data: %u %d\n", *pubArray, count);
            lidarPub->publish();
            count++;
        }
    }
    return count;
}


 /** ----------------------------------------------------------------
 * participant_main()
 **/
void participant_main(int domain_id)
{
    // Create a DomainParticipant with default Qos
    dds::domain::DomainParticipant participant(domain_id);

    // Instantiate a publisher of PointCloud2(LiDAR) and init the sample
    uint32_t opt_en = (1 << CROS2_PUB_ON);
    cros2pointcloud myLidarOut(std::string("cloud_echo"), opt_en, participant);
    lidarPub = &myLidarOut;
    myLidarOut.pub_sample_config_fields(PTCLOUD2_FMT_XYZ_RGB8_FLOAT32);
    myLidarOut.pub_sample_isdense_set(true);
    myLidarOut.pub_sample_isbigendian_set(false);
    myLidarOut.pub_sample_header_frameid_set("map");
    myLidarOut.pub_sample_size_xy_set(1, 512);         // array size is: (x * y * 16) bytes
    ptcData = myLidarOut.get_send_data_buffer();
    pubArray = (uint8_t *)ptcData;
    uint32_t pointsTotal = myLidarOut.pub_sample_height_get() * myLidarOut.pub_sample_width_get();
    for (uint32_t i = 0; i < pointsTotal; i++)
    {
        *(ptcData + i) = static_cast<float>((rand() % 1000) / 100.0f);
    }

    // instantiate a subscriber of PointCloud2
    int(*rcv_handler)(dds::sub::DataReader<sensor_msgs::msg::dds_::PointCloud2_>);
    rcv_handler = (int(*)(dds::sub::DataReader<sensor_msgs::msg::dds_::PointCloud2_>))ptcloud2_benchRcv;
    cros2pointcloud myCloudSub(std::string("cloud_call"), (1 << CROS2_SUB_ON), participant, rcv_handler);

    int data_cnt_ref = myCloudSub.data_rcv_count_get();
    int fast_poll_cnt = 0;
    // main loop --------------------------------------------------------------
    for (int wcount = 0; 1; wcount++) {
#if 1
        if (fast_poll_cnt == 0) {
            // slower waitset checking
            myCloudSub.datarcv_waitset(0, 100000000);
            // did data arrive?
            if (data_cnt_ref != myCloudSub.data_rcv_count_get()) {
                // yes -- go to rapid waitset dispatch
                data_cnt_ref = myCloudSub.data_rcv_count_get();
                fast_poll_cnt = 1000;
            }
        }
        else {
            // rapid waitset dispatch; effectively polling
            myCloudSub.datarcv_waitset(0, 30000);
            fast_poll_cnt--;
            // check every nth loop 
            if ((fast_poll_cnt & 0xff) == 0) {
                if (data_cnt_ref != myCloudSub.data_rcv_count_get()) {
                    // data is still coming in
                    data_cnt_ref = myCloudSub.data_rcv_count_get();
                    fast_poll_cnt = 1000;
                }
            }
        }
#else
        // rapid waitset; effectively polling
        myCloudSub.datarcv_waitset(0, 30000);
        //printf(".");
#endif
    }
}

/** ----------------------------------------------------------------
 * main()
 **/
int main(int argc, char *argv[])
{
    int domain_id = 0;

    if (argc >= 2) {
        domain_id = atoi(argv[1]);
    }

    // To turn on additional logging, include <rti/config/Logger.hpp> and
    // uncomment the following line:
    // rti::config::Logger::instance().verbosity(rti::config::Verbosity::STATUS_ALL);

    try {
        participant_main(domain_id);
    }
    catch (const std::exception& ex) {
        // This will catch DDS exceptions
        std::cerr << "Exception in participant_main(): " << ex.what() << std::endl;
        return -1;
    }

    // RTI Connext provides a finalize_participant_factory() method
    // if you want to release memory used by the participant factory singleton.
    // Uncomment the following line to release the singleton:
    //
    // dds::domain::DomainParticipant::finalize_participant_factory();

    return 0;
}

