/*
* (c) Copyright, Real-Time Innovations, 2012.  All rights reserved.
* RTI grants Licensee a license to use, modify, compile, and create derivative
* works of the software solely for use with RTI Connext DDS. Licensee may
* redistribute copies of the software provided that all such copies are subject
* to this license. The software is provided "as is", with no warranty of any
* type, including any warranty for fitness for any purpose. RTI is under no
* obligation to maintain or support the software. RTI shall not be liable for
* any incidental or consequential damages arising out of the use or inability
* to use the software.
*/

/** ================================================================
 * bmp_view_demo.cxx
 * Publishes ROS2 PointCloud2, OccupancyGrid, and Image data types, 
 *  for viewing in ROS2 RViz2, from a series of .bmp image files.
 * Uses data type support code generated by the rtiddsgen command:
 *   rtiddsgen -language C++11 cros2_types.idl
 *
 **/

#include <algorithm>
#include <iostream>
#include <rti/util/util.hpp>                // for sleep()
#include "cros2_pointcloud_support.hpp"     // for ROS 2 PointCloud2 (LiDAR) export
#include "cros2_occupancygrid_support.hpp"  // for ROS 2 OccupancyGrid (Map) export
#include "cros2_image_support.hpp"          // for ROS 2 Image export

const float PI_F = 3.14159265359f;

 /** ----------------------------------------------------------------
  * read_ptcloud_bitmap()
  * Given a filename for a larger .bmp file, open and read the
  *  contents into a new allocated array pointed-to by *imgData.
  * Assumes the image file types is: .bmp bitmap, 24 bits per pixel.
  * Returns 0 if no error.
  **/
int read_ptcloud_bitmap(
    uint8_t **imgData, 
    uint32_t *imgRows, 
    uint32_t *imgCols, 
    const char *fileName)
{
    FILE *fp;
    if ((fp = fopen(fileName, "rb")) == NULL) {
        fprintf(stderr, "ERROR: cannot open file %s for reading (%s:%d)\n", fileName, __FILE__, __LINE__);
        return -1;
    }

    // read in the first part of the file to get stats
    uint8_t bmpHeader[35];
    int bIdx = 0;
    bIdx = (int)fread(static_cast<uint8_t *>(bmpHeader), sizeof(uint8_t), 34, fp);

    // bytes 2-5 are the total size of the file
    uint32_t fileSize = *((uint32_t *)&bmpHeader[2]);

    // bytes 18-21 are image width (X dim, number of columns)
    *imgCols = *((uint32_t *)&bmpHeader[18]);

    // bytes 22-25 are image height (Y dim, number of rows)
    *imgRows = *((uint32_t *)&bmpHeader[22]);

    // bytes 14-10 are the offset to the start of the data
    uint32_t dOffset = *((uint32_t *)&bmpHeader[10]);

    // Allocate memory for size of image
    uint32_t imgDataSize = fileSize - dOffset;
    if ((*imgData = (uint8_t *)malloc(imgDataSize)) == NULL) {
        fprintf(stderr, "ERROR: alloc fail of (%u) at (%s:%d)\n", imgDataSize, __FILE__, __LINE__);
        return -2;
    }

    // read the data
    fseek(fp, dOffset, SEEK_SET);
    fread((uint8_t *)*imgData, sizeof(uint8_t), (imgDataSize), fp);
    fclose(fp);
    return 0;
}

/** ----------------------------------------------------------------
 * ptcloud_build_img_export()
 * Given an image buffer containing 24bpp .bmp data, make random 
 *  pixel selections for pointcloud2 export.
 * In->out transform will be:
 *  X(0:ImgCols) --> X(-5:5)
 *  Y(0:ImgRows) --> Z(0:10)
 *  Pixel Color  --> Y(-5:5)
 **/
void ptcloud_build_img_export(uint8_t *imgData, int imgRows, int imgCols, uint32_t pointsTotal, float *ptcData)
{
    static uint32_t lfsr = 0x08675309;
    uint32_t pcIdx = 0;
    uint32_t addPad = ((imgCols * 3) % 4);
    if (addPad) addPad = 4 - addPad;
    while (pcIdx < pointsTotal) {
        uint32_t tmpX = lfsr % imgCols;
        lfsr = (lfsr >> 1) ^ (-(lfsr & 1u) & 0xD0000001u);
        uint32_t tmpY = lfsr % (imgRows - 2);
        lfsr = (lfsr >> 1) ^ (-(lfsr & 1u) & 0xD0000001u);
        uint32_t randPixBase = (tmpY * imgCols * 3) + (tmpX * 3);
        randPixBase += (tmpY * addPad);
        uint8_t pixRed = imgData[randPixBase];
        uint8_t pixGrn = imgData[randPixBase+1];
        uint8_t pixBlu = imgData[randPixBase+2];
        uint32_t pcColor = ((((uint32_t)pixBlu) << 16) | (((uint32_t)pixGrn) << 8) | ((uint32_t)pixRed));

        // fold the Y range around the midpoint, placing the brightest and dimmest values to the rear (higher Y values)
        float pcYval = ((fabsf(((float)(pixRed + pixGrn + pixBlu) - 0x17F))) / 192.0F) + 3.0F;
        ptcData[(pcIdx * 4) + 0] = (((float)tmpX * 10.0F) / imgCols) - 5.0F;    // X
        ptcData[(pcIdx * 4) + 1] = pcYval;                                      // Y
        ptcData[(pcIdx * 4) + 2] = (((float)tmpY * 10.0F) / imgRows);           // Z
        ptcData[(pcIdx * 4) + 3] = *reinterpret_cast<float*>(&pcColor);;        // Color
        pcIdx++;
       
    }
}


/** ----------------------------------------------------------------
 * participant_main()
 **/
void participant_main(int domain_id)
{
    // Create a DomainParticipant with default Qos
    dds::domain::DomainParticipant participant(domain_id);

    // Instantiate an exporter of PointCloud2(LiDAR) and init the sample
    uint32_t opt_en = (1 << CROS2_PUB_ON);
    cros2pointcloud myLidarOut(std::string("lidar_points"), opt_en, participant);
    myLidarOut.pub_sample_config_fields(PTCLOUD2_FMT_XYZ_RGB8_FLOAT32);
    myLidarOut.pub_sample_isdense_set(true);
    myLidarOut.pub_sample_isbigendian_set(false);
    myLidarOut.pub_sample_header_frameid_set("map");
    myLidarOut.pub_sample_size_xy_set(200, 5);
    float *ptcData = myLidarOut.get_send_data_buffer();
    uint32_t pointsTotal = myLidarOut.pub_sample_height_get() * myLidarOut.pub_sample_width_get();

    // Instantiate an exporter of OccupancyGrid (Map), and init the sample
    opt_en = (1 << CROS2_PUB_ON);
    cros2occupancygrid myOgridOut(std::string("floor_map"), opt_en, participant);
    int ogridRows = 96;     // 96x96=9216 (max size set in IDL file)
    int ogridCols = 96;
    myOgridOut.pub_sample_grid_xy_set(ogridCols, ogridRows);
    myOgridOut.pub_sample_resolution_set((10.0F / (float)ogridCols));
    myOgridOut.pub_sample_orig_pos_x_set(-5.0F);
    myOgridOut.pub_sample_orig_pos_y_set(-5.0F);
    myOgridOut.pub_sample_orig_pos_z_set(0);
    myOgridOut.pub_sample_orig_orient_w_set(PI_F);
    myOgridOut.pub_sample_frame_id_set("map");

    // instantiate an exporter of ROS 2 Image data and init the sample
    opt_en = (1 << CROS2_PUB_ON);
    cros2image myImageOut(std::string("cam_image"), opt_en, participant);
    myImageOut.pub_sample_encoding_set("bgr8");
    myImageOut.pub_sample_isbigendian_set(false);
    myImageOut.pub_sample_header_frameid_set("map");
    myImageOut.pub_sample_size_xy_set(320, 200);


    // PointCloud data will be taken from an image file
    int maxImgCount = 6;
    const char *imgFileList[6];
    imgFileList[0] = "./img/L1.bmp";
    imgFileList[1] = "./img/L2.bmp";
    imgFileList[2] = "./img/L3.bmp";
    imgFileList[3] = "./img/L4.bmp";
    imgFileList[4] = "./img/L5.bmp";
    imgFileList[5] = "./img/L6.bmp";

    uint32_t imgRows = 0;
    uint32_t imgCols = 0;
    uint8_t *imgData = NULL;
    int imgIdx = 0;

    // main loop --------------------------------------------------------------
    for (int wcount = 0; 1; wcount++) {

        if (!(wcount % 150)) {
            if (imgData) {
                free(imgData);
            }
            if (read_ptcloud_bitmap(&imgData, &imgRows, &imgCols, imgFileList[imgIdx])) {
                fprintf(stderr, "ERROR: Cannot open file (%s:%d)\n", __FILE__, __LINE__);
                return;
            }
            if (++imgIdx >= maxImgCount) {
                imgIdx = 0;
            }
            // try sending the image to ROS2 'Image' data type
            myImageOut.publish_scaled(imgData, imgCols, imgRows);
            myOgridOut.publish_scaled(imgData, imgCols, imgRows);
        }

        // use the image data as a source of pointcloud points, selected randomly
        ptcloud_build_img_export(imgData, imgRows, imgCols, pointsTotal, ptcData);
        myLidarOut.publish();
        rti::util::sleep(dds::core::Duration(0, 100000000));
    }
}

/** ----------------------------------------------------------------
 * main()
 **/
int main(int argc, char *argv[])
{
    int domain_id = 0;

    if (argc >= 2) {
        domain_id = atoi(argv[1]);
    }

    // To turn on additional logging, include <rti/config/Logger.hpp> and
    // uncomment the following line:
    // rti::config::Logger::instance().verbosity(rti::config::Verbosity::STATUS_ALL);

    try {
        participant_main(domain_id);
    }
    catch (const std::exception& ex) {
        // This will catch DDS exceptions
        std::cerr << "Exception in participant_main(): " << ex.what() << std::endl;
        return -1;
    }

    // RTI Connext provides a finalize_participant_factory() method
    // if you want to release memory used by the participant factory singleton.
    // Uncomment the following line to release the singleton:
    //
    // dds::domain::DomainParticipant::finalize_participant_factory();

    return 0;
}

