/** ==================================================================
 * cros2_occupancygrid_support.hpp
 * Class for interfacing a native Connext DDS application with the 
 *  ROS 2 nav_msgs::msg::dds_::OccupancyGrid_ data type. 
 * This program uses the C++11 option of RTIDDSGen, using the type
 *  support source code generated by the command line:
 *   rtiddsgen -language C++11 <arch> cros2_types.idl
 **/

#ifndef __CROS2_OCCUPANCYGRID_SUPPORT_HPP__
#define __CROS2_OCCUPANCYGRID_SUPPORT_HPP__
#include "cros2_common.hpp"             // common includes and defs
#include "nav_msgs/msg/OccupancyGridPlugin.hpp"

// struct for occupancygrid configuration
typedef struct {
    int             rowCount;
    int             colCount;
}ogrid_data_cfg;

/** ----------------------------------------------------------------
 * cros2occupancygrid class
 * This class supports ROS2 turtlesim with methods that are not 
 *  tied to a specific turtle:
 *  Spawn, Kill, Clear, Reset, Parameters and Logging
 * See 'turtleinst' class for specific-turtle methods.
 * ------------------------------------------------------------- **/
class cros2occupancygrid
{
public:
    cros2occupancygrid(const std::string ogridName, uint32_t opt_en, dds::domain::DomainParticipant participant);
    ~cros2occupancygrid();

    void publish(void);
    nav_msgs::msg::dds_::OccupancyGrid_ *sample_to_pub(void) { return &pub_sample; }
    uint8_t *getDataPtr(void) { return pub_sample.data().data(); }
    void publish_scaled(uint8_t *imgBuf, uint32_t inX, uint32_t inY);

    // OccupancyGrid data sample accessors
    void pub_sample_width_set(uint32_t newX) { pub_sample.info().width(newX); }
    void pub_sample_height_set(uint32_t newY) { pub_sample.info().height(newY); }
    void pub_sample_resolution_set(float newRes) { pub_sample.info().resolution(newRes); }
    void pub_sample_orig_pos_x_set(float newX) { pub_sample.info().origin().position().x(newX); }
    void pub_sample_orig_pos_y_set(float newY) { pub_sample.info().origin().position().y(newY); }
    void pub_sample_orig_pos_z_set(float newZ) { pub_sample.info().origin().position().z(newZ); }
    void pub_sample_orig_orient_w_set(float newW) { pub_sample.info().origin().orientation().w(newW); }
    void pub_sample_grid_xy_set(uint32_t newX, uint32_t newY) { 
        pub_sample.info().width(newX);
        pub_sample.info().height(newY);
        pub_sample.data().resize(newX * newY);
    }
    void pub_sample_frame_id_set(const std::string newId) {pub_sample.header().frame_id(newId);  }

    uint32_t pub_sample_width_get(void) { return pub_sample.info().width(); }
    uint32_t pub_sample_height_get(void) { return pub_sample.info().height(); }
    float pub_sample_resolution_get(void) { return pub_sample.info().resolution(); }
    float pub_sample_orig_pos_x_get(void) { return (float)pub_sample.info().origin().position().x(); }
    float pub_sample_orig_pos_y_get(void) { return (float)pub_sample.info().origin().position().y(); }
    float pub_sample_orig_pos_z_get(void) { return (float)pub_sample.info().origin().position().z(); }
    int data_rcv_count_get(void) { return data_rcv_count; }

private:
    // DDS receive data handler
    int rcv_dataProc(dds::sub::DataReader<nav_msgs::msg::dds_::OccupancyGrid_> & reader);

    // DDS Topic, DataWriter, DataReader, Sample(for publish)
    dds::topic::Topic<nav_msgs::msg::dds_::OccupancyGrid_> data_topic;
    dds::pub::DataWriter<nav_msgs::msg::dds_::OccupancyGrid_> data_wr;
    dds::sub::DataReader<nav_msgs::msg::dds_::OccupancyGrid_> data_rd;
    nav_msgs::msg::dds_::OccupancyGrid_ pub_sample;

    // misc
    dds::core::cond::WaitSet waitset;
    int data_rcv_count;
};
#endif  // ndef __CROS2_OCCUPANCYGRID_SUPPORT_HPP__