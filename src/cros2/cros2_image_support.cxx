/** ==================================================================
 * FILE: cros2_image_support.cxx
 * Class for interfacing a native Connext DDS application with the
 *  ROS 2 sensor_msgs::msg::dds_::Image data type.
 * This program uses the C++11 option of RTIDDSGen, using the type
 *  support source code generated by the command line:
 *   rtiddsgen -language C++11 <typedef-file.idl>
 **/
#include "cros2_image_support.hpp"

/*ci
 * \brief cros2image class constructor
 *
 * \details
 * Instantiate an Image publisher and/or subscriber with supporting
 * writer, reader, topic, etc.
 *
 * \param[in]    imageName    Name of the Image topic 
 * \param[in]    opt_en       bitfield of options (pub, sub) to enable
 * \param[in]    participant  DDS participant, already created
 */
cros2image::cros2image(const std::string imageName, uint32_t opt_en, dds::domain::DomainParticipant participant,
    int(*rcv_fptr)(dds::sub::DataReader<sensor_msgs::msg::dds_::Image_>)) :
    data_topic(dds::core::null), pub_sample(),
    data_wr(dds::core::null), data_rd(dds::core::null),
    waitset()
{
    // create topic (pub or sub)
    const std::string data_topname("rt/" + imageName);
    data_topic = dds::topic::Topic<sensor_msgs::msg::dds_::Image_>(participant, data_topname);

    if (opt_en & (1 << CROS2_PUB_ON)) {
        // DataWriter
        data_wr = dds::pub::DataWriter<sensor_msgs::msg::dds_::Image_>(dds::pub::Publisher(participant), data_topic);

    }

    if (opt_en & (1 << CROS2_SUB_ON)) {
        // DataReader, ReadCondition, WaitSet
        data_rd = dds::sub::DataReader<sensor_msgs::msg::dds_::Image_>(dds::sub::Subscriber(participant), data_topic);
        dds::sub::cond::ReadCondition data_readCond(
            data_rd, dds::sub::status::DataState::any(),
            [rcv_fptr, this](/* dds::core::cond::Condition condition */)
        {
            if (rcv_fptr == NULL) {
                // use the default receive handler if no other was specified
                data_rcv_count += rcv_dataProc(data_rd);
            }
            else {
                // use the specified receive handler
                data_rcv_count += rcv_fptr(data_rd);
            }
        }
        );
        waitset += data_readCond;
    }
}

// Receive data handler
int cros2image::rcv_dataProc(dds::sub::DataReader<sensor_msgs::msg::dds_::Image_>& reader)
{
    int count = 0;
    dds::sub::LoanedSamples<sensor_msgs::msg::dds_::Image_> samples = reader.take();
    for (const auto& sample : samples) {
        if (sample.info().valid()) {
            count++;
            //std::cout << "Image " << sample.data() << std::endl;
        }
    }
    return count;
}

 /*ci
  * \brief Publish the Image topic.
  *
  * \details
  * Timestamp and publish the Image_ topic
  *
  */
void cros2image::publish(void)
{
    timespec ts;
    tstamp_get(&ts);
    pub_sample.header().stamp().sec((int32_t)ts.tv_sec);
    pub_sample.header().stamp().nanosec(ts.tv_nsec);
    data_wr.write(pub_sample);
    return;
}

/*ci
 * \brief Scale and publish an RGB8 image buffer
 * 
 * \details
 * Given an RGB8 image in a buffer (plus x,y resolution), will scale
 * the image down to fit within the send buffer by doing a reduction 
 * in pixels with averaged colors.
 *
 * \param[inout] imgBuf Image buffer, in a 3-byte R,G,B sequence.
 * \param[in]    inX    X (horiz) resolution of the input image
 * \param[in]    inY    Y (vert) resolution of the input image
 * 
 * \return       void
 */
void cros2image::publish_scaled(uint8_t *imgBuf, uint32_t inX, uint32_t inY)
{
    uint8_t *sendBuf = getDataPtr();
    uint32_t pub_image_x = pub_sample_width_get();
    uint32_t pub_image_y = pub_sample_height_get();
    float factor_X = (((float)inX) / pub_image_x);
    float factor_Y = (((float)inY) / pub_image_y);
    uint32_t ipX = 0;
    uint32_t ipY = 0;
    uint32_t addPad = ((inX * 3) % 4);
    if (addPad) addPad = 4 - addPad;

    for (uint32_t outY = 0; outY < pub_image_y; outY++) {
        for (uint32_t outX = 0; outX < pub_image_x; outX++) {
            // for each outX, get the average of the pixels in the (factor_x * factor_y) area nearby
            uint32_t pixR = 0;
            uint32_t pixG = 0;
            uint32_t pixB = 0;
            uint32_t pixCnt = 0;
            ipX = (uint32_t)(outX * factor_X);
            uint32_t iStopX = (uint32_t)((outX + 1) * factor_X);
            ipY = (uint32_t)(outY * factor_Y);
            uint32_t iStopY = (uint32_t)((outY + 1) * factor_Y);
            for (; ipY < iStopY; ipY++) {
                for (uint32_t itX = ipX; itX < iStopX; itX++) {
                    pixR += imgBuf[(ipY * inX * 3) + (itX * 3) + (addPad * ipY)];
                    pixG += imgBuf[(ipY * inX * 3) + (itX * 3) + (addPad * ipY) + 1];
                    pixB += imgBuf[(ipY * inX * 3) + (itX * 3) + (addPad * ipY) + 2];
                    pixCnt++;
                }
            }
            // assign the averages to the output array
            sendBuf[((pub_image_y - outY - 1) * pub_image_x * 3) + (outX * 3) + 0] = (pixR / pixCnt);
            sendBuf[((pub_image_y - outY - 1) * pub_image_x * 3) + (outX * 3) + 1] = (pixG / pixCnt);
            sendBuf[((pub_image_y - outY - 1) * pub_image_x * 3) + (outX * 3) + 2] = (pixB / pixCnt);
        }
    }
    publish();
    return;
}


// destructor
cros2image::~cros2image() {}
