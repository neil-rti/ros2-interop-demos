/** ==================================================================
 * FILE: cros2_path_support.cxx
 * Class for interfacing a native Connext DDS application with the 
 *  ROS 2 nav_msgs::msg::dds_::Path_ data type.
 * This program uses the C++11 option of RTIDDSGen, using the type
 *  support source code generated by the command line:
 *   rtiddsgen -language C++11 <typedef-file.idl>
 **/
#include "cros2_path_support.hpp"

/*ci
 * \brief cros2path class constructor
 *
 * \details
 * Instantiate a nav_msgs::msg::dds_::Path_ publisher
 * and/or subscriber with supporting writer, reader, topic, etc.
 *
 * \param[in]    pathName      Name of the DDS topic
 * \param[in]    opt_en        bitfield of options (pub, sub) to enable
 * \param[in]    participant   DDS participant, already created
 */
cros2path::cros2path(const std::string pathName, uint32_t opt_en, dds::domain::DomainParticipant participant,
    int(*rcv_fptr)(dds::sub::DataReader<nav_msgs::msg::dds_::Path_>)) :
    data_topic(dds::core::null), pub_sample(),
    data_wr(dds::core::null), data_rd(dds::core::null),
    waitset()
{
    // create topic (pub or sub)
    const std::string data_topname("rt/" + pathName);
    data_topic = dds::topic::Topic<nav_msgs::msg::dds_::Path_>(participant, data_topname);

    if (opt_en & (1 << CROS2_PUB_ON)) {
        // DataWriter
        data_wr = dds::pub::DataWriter<nav_msgs::msg::dds_::Path_>(dds::pub::Publisher(participant), data_topic);
    }

    if (opt_en & (1 << CROS2_SUB_ON)) {
        // DataReader, ReadCondition, WaitSet
        data_rd = dds::sub::DataReader<nav_msgs::msg::dds_::Path_>(dds::sub::Subscriber(participant), data_topic);
        dds::sub::cond::ReadCondition data_readCond(
            data_rd, dds::sub::status::DataState::any(),
            [rcv_fptr, this](/* dds::core::cond::Condition condition */)
        {
            if (rcv_fptr == NULL) {
                // use the default receive handler if no other was specified
                data_rcv_count += rcv_dataProc(data_rd);
            }
            else {
                // use the specified receive handler
                data_rcv_count += rcv_fptr(data_rd);
            }
        }
        );
        waitset += data_readCond;
    }
}

// Receive data handler
int cros2path::rcv_dataProc(dds::sub::DataReader<nav_msgs::msg::dds_::Path_>& reader)
{
    int count = 0;
    dds::sub::LoanedSamples<nav_msgs::msg::dds_::Path_> samples = reader.take();
    for (const auto& sample : samples) {
        if (sample.info().valid()) {
            count++;
            //std::cout << "add " << sample.data() << std::endl;
        }
    }
    return count;
}


/*ci
 * \brief Publish the Path_ topic.
 *
 * \details
 * Timestamp and publish the Path_ topic
 *
 */
void cros2path::publish(void)
{ 
    timespec ts;
    tstamp_get(&ts);
    // path has a header, but each PoseStamped_ element also has a header.
    pub_sample.header().stamp().sec((int32_t)ts.tv_sec);
    pub_sample.header().stamp().nanosec(ts.tv_nsec);
#if 0    // stamp them all
    for (int i = 0; i < pub_sample.poses().size(); i++) {
        pub_sample.poses().at(i).header().stamp().sec((int32_t)ts.tv_sec);
        pub_sample.poses().at(i).header().stamp().nanosec(ts.tv_nsec);
    }
#endif
    data_wr.write(pub_sample); 
}

// destructor
cros2path::~cros2path() {}
